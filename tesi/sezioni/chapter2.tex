\myChapter{Nozioni di base}

\section{Blockchain}
Nella sua più primitiva definizione una blockchain è una struttura dati in grado di registrare informazioni e garantirne l'immutabilità nel tempo, ridondando i dati su un gran numero di nodi senza che sia necessaria un'entità centrale che vigili su possibili minacce o malfunzionamenti. Concepita nel 2008 dallo pseudonimo Satoshi Nakamoto, la cui vera identità è tutt'oggi sconosciuta, \cite{satoshi} come mezzo per decentralizzare il mondo delle transazioni finanziarie, è stata oggetto nel corso del tempo di un forte interesse accademico e commerciale venendo applicata in un gran numero di scenari diversi. Pur essendo presenti sul panorama attuale svariati esempi di blockchain anche molto diverse tra loro in complessità e implementazione, possiamo individuarne alcune concetti di base comuni a tutte loro.

\subsection{Struttura a blocchi}
Ogni blockchain è composta da vari blocchi di informazione legati fra loro tramite l'uso di hash crittografici (sez.~\ref{hash}). Infatti per garantire l'integrità dei dati ogni blocco contiene l'hash del blocco precedente, così che un cambiamento nell'informazione contenuta in un blocco verrà subito riconosciuto da un semplice controllo sugli hash. All'interno di un blocco le informazioni sono generalmente organizzate in una lista di transazioni, chiamate così a causa del loro concepimento in ambiente di transazioni economiche nella rete Bitcoin.

Per ottimizzare il processo di hashing delle transazioni viene generalmente impiegato un albero di Merkle: si costruisce un albero binario avente come foglie gli hash di tutte le transazioni di un blocco e ogni altro nodo conterrà l'hash della concatenazione dei suoi due figli. Procedendo così dal basso verso l'alto l'hash contenuto nella radice dell'albero sarà l'hash che rappresenterà l'intera lista di transazioni e l'unico elemento che verrà incluso nel calcolo dell'hash del blocco. Tale struttura ad albero permette una notevole flessibilità nel processo di verifica delle transazioni, infatti se si è interessati alla verifica dell'integrità di una singola transazione basterà chiedere agli altri nodi di fornire gli hash intermedi utili a ricostruire solo il particolare ramo della transazione in esame. Del resto una modifica a una transazione qualsiasi comporterebbe una modifica in cascata di tutti gli hash fino a quello di radice, venendo bloccata subito dal controllo degli hash sui blocchi.

\subsection{Modalità di accesso e permessi}
Una prima differenza fondamentale delle blockchain è la modalità con cui i nuovi nodi possono entrare a far parte della rete. Nelle blockchain pubbliche qualunque dispositivo può diventare un nodo della rete senza alcun controllo sulla sua legittimità. In generale questo tipo di blockchain presenta un numero di partecipanti molto elevato grazie alla bassa soglia di entrata. Nelle blockchain private invece l'entrata nella rete è preceduta da una fase di autenticazione del soggetto come l'appartenenza a una determinata azienda. Tali blockchain sono quindi confinate nelle realtà che le sviluppano e le loro pool di nodi sono di conseguenza molto ridotte in quanto solo chi è qualificato può entrare a farne parte. Le blockchain pubbliche sono di gran lunga il tipo più comune di blockchain, ma quelle private stanno guadagnando terreno avendo attirato l'attenzione del mondo finanziario \cite{HELLIAR2020102136}.

Un'altra differenza importante sono i permessi rilasciati a un nodo a seguito della sua entrata nella rete. Nelle blockchain pubbliche non viene generalmente assunta alcuna distinzione gerarchica tra i nodi, chiunque può sfruttare tutte le funzioni disponibili senza restrizioni. Per questo motivo le blockchain pubbliche sono spesso sinonimo di blockchain senza permesso (permissionless). D'altra parte nelle blockchain private è comune che la gerarchia dell'organizzazione proprietaria della rete si rifletta sui nodi stessi, essendo presenti responsabilità e permessi diversi a seconda dell'identità corrispondente a ciascun nodo, da qui la comune associazione tra blockchain private e blockchain con permesso (permissioned). Possiamo identificare inoltre un terzo tipo di blockchain emergente, quello ibrido, in cui vengono uniti le caratteristiche delle blockchain pubbliche con quelle permissioned. Si tratta di blockchain ad accesso libero, ma all'interno delle quali solo alcune funzionalità sono disponibili a tutti, mentre altre richiedono una preventiva autenticazione del nodo.

\subsection{Algoritmo di consenso}
Data la natura distribuita di una blockchain è di fondamentale importanza la ricerca del consenso tra i nodi, ovvero che ogni transazione generata venga validata e diffusa attraverso la rete rimanendo inalterata. Nasce quindi il bisogno di un procedimento rigoroso mediante il quale i singoli nodi possano scegliere quali blocchi aggiungere alla propria catena locale, sicuri che tutti gli altri nodi allungheranno le rispettive catene in modo identico. Il primo algoritmo di consenso concepito ad assolvere tale scopo è la proof of work: l'immutabilità dei dati è garantita dalla difficoltà di computare rapidamente un puzzle crittografico. Nella rete Bitcoin ad esempio un nuovo blocco è considerato valido quando viene trovato un numero tale che, inserito nell'header del blocco stesso, rende il suo hash inferiore a un certo numero. Variando tale numero è possibile modulare il carico dei blocchi generati dall'intera rete, dando così il tempo ai blocchi di diffondersi tra i vari nodi. Ogni nodo dà la sua fiducia alla catena di blocchi in cui è stata spesa la maggior quantità di lavoro computazionale. Un algoritmo di consenso concepito più recentemente è la proof of stake: i nuovi blocchi vengono validati da nodi scelti casualmente in base a quanta valuta hanno investito nella rete. Pur ritenendo un certo livello di casualità, l'algoritmo di selezione del prossimo validatore privilegia i maggiori scommettitori. La legittimità della rete è garantita perciò dal fatto che chi ha investito maggiormente avrà interesse nel suo corretto funzionamento. La rete Ethereum prevede di effettuare il cambio da proof of work a proof of stake nei prossimi anni. Per un'analisi dettagliata sugli algoritmi di consenso fare riferimento a \cite{8632190}.

\subsection{Privacy e sicurezza}
Nelle blockchain pubbliche il contenuto dei blocchi è disponibile a ogni nodo senza alcuna protezione. Assume grande importanza quindi avere sempre ben presente quali informazioni si stanno immettendo nella rete in chiaro e quali invece si cerca di proteggere. Nella rete Bitcoin tutto il contenuto di un blocco è presente completamente in chiaro tanto da poter ricostruire la storia di ogni singolo Bitcoin fino al momento della sua coniazione. In questo caso la privacy offerta agli utenti si limita alla loro anonimizzazione nella rete offrendo indirizzi usa e getta senza legami con l'identità legale del soggetto che li possiede. Anche la rete Ethereum non prevede di base alcuna forma di cifratura del contenuto dei blocchi, essendo tuttavia presenti delle forme di privacy a zero conoscenza implementabili come zk-SNARKS per nascondere integralmente il contenuto di una transazione \cite{snark}. Discorso diverso invece per le blockchain private in quanto la preventiva autenticazione dei nodi permette di garantire che le informazioni contenute nei blocchi siano consultabili solo da soggetti autorizzati, non rendendo necessari complessi sistemi di crittografia per garantire la riservatezza delle informazioni.

\subsection{Confronto di alcune blockchain}
Di seguito una comparazione di tre grandi blockchain moderne con \mbox{UniBlock}:
\newline
\newline
\centerline{
\begin{tabular}{ |c||c|c|c|c| } 
 \hline
 & \large{\textit{\textbf{Accesso}}} & \large{\textit{\textbf{Permessi}}} & \large{\textit{\textbf{Consenso}}} & \large{\textit{\textbf{Privacy}}} \\ 
 \hline
 \hline
 \large{\textit{\textbf{Bitcoin}}} & Pubblica & Permissionless & Proof of work & Non crittografata \\ 
 \hline
 \large{\textit{\textbf{Ethereum}}} & Pubblica & Permissionless & Proof of work & Non crittografata \\ 
 \hline
 \large{\textit{\textbf{Hyperledger Fabric}}} & Privata & Permissioned & Crash Fault Tolerance & Non crittografata \\ 
 \hline
 \large{\textit{\textbf{UniBlock}}} & Pubblica & Permissioned & Proof of work & Crittografata \\
 \hline
\end{tabular}
}
\newline
\newline
\newline
Bitcoin ed Ethereum sono blockchain pubbliche in cui il contenuto dei blocchi è completamente in chiaro e consultabile da chiunque, Hyperledger Fabric invece risulta essere una blockchain privata in cui la protezione dei dati contenuti all'interno dei blocchi è implicita nella natura privata della rete. UniBlock si propone come ibrido tra questi due approcci: una blockchain pubblica e liberamente consultabile, ma il cui contenuto dei blocchi è protetto e interpretabile solo da soggetti specifici.

\section{Crittografia}

\subsection{Hash crittografico} \label{hash}
Una funzione hash è una funzione che trasforma un input di dimensione arbitraria in un output di dimensione fissa. Per poter essere impiegata in crittografia una funzione hash deve rispettare forti vincoli di sicurezza:
\begin{description}
  \item[Resistenza alla pre-immagine] Dato un particolare hash \(h\), dev'essere estremamente difficoltoso trovare un input che abbia come hash \(h\). La funzione di hash deve quindi risultare una funzione one-way, cioè una funzione la cui inversa è impossibile da costruire o computazionalmente non eseguibile in tempi accettabili.
  \item[Seconda resistenza alla pre-immagine] Dato un un particolare input \(a\), dev'essere estremamente difficoltoso trovare un altro input che abbia lo stesso hash di \(a\).
  \item[Resistenza alle collisioni] Dev'essere estremamente difficoltoso trovare due input che abbiano lo stesso hash.
\end{description}

\subsection{Crittografia simmetrica}
Gli algoritmi a chiave simmetrica impiegano la stessa chiave per cifrare un testo e per decifrarlo successivamente. Le due tipologie principali di algoritmi a chiave simmetrica sono:
\begin{description}
  \item[Cifrari a blocchi] L'algoritmo prende in input un numero fisso di bit e li cripta combinandoli con la chiave restituendo lo stesso numero di bit criptati in uscita. Gli unici input accettabili sono di dimensione pari al blocco di bit usato, qualunque altro input dovrà essere opportunamente allungato se troppo corto o troncato se troppo lungo. Solo usando l'algoritmo in particolari modalità di operazione potrà essere possibile permettere input di dimensione arbitraria.
  \item[Cifrari a flusso] L'algoritmo combina l'input con un flusso pseudo random di bit derivato dalla chiave. Al contrario dei cifrari a blocchi non presentano problemi di dimensione dell'input, in quanto il flusso generato verrà calibrato esattamente della lunghezza necessaria per ciascun input.
\end{description}

\subsection{Modalità di operazione}
Data l'estrema restrittiva dei cifrari a blocchi che permettono di criptare solo un blocco di bit di dimensione fissa, sono stati concepiti diversi modi di usare tali cifrari per garantirne certe proprietà o per renderne più agevole l'uso in alcune situazioni:
\begin{description}
  \item[ECB] L'input viene partizionato in blocchi di dimensione fissa e ognuno viene criptato singolarmente.
  \item[CBC] L'input viene partizionato in blocchi di dimensione fissa e criptato mettendolo in xor con il blocco criptato precedente.
  \item[CTR] L'input viene partizionato in blocchi di dimensione fissa e ogni blocco viene criptato con una chiave generata a partire da una funzione sequenziale. Permette di fatto di trasformare un cifrario a blocchi in uno a flusso.
  \item[GCM] Modalità molto simile a CTR in quanto permette tramite la derivazione sequenziale di una chiave di trasformare un cifrario a blocchi in uno a flussi. Aggiunge mediante l'uso dei campi di Galois una firma che garantisce l'integrità del processo di cifratura.
\end{description}

\subsection{Crittografia asimmetrica}
Gli algoritmi a chiave pubblica impiegano due chiavi diverse, una per cifrare e una per decifrare. Quella per cifrare è chiamata chiave pubblica in quanto non costituisce segreto ed è liberamente distribuibile senza protezioni. Quella per decifrare invece è chiamata chiave segreta e deve essere mantenuta appunto segreta e nota solo alla persona che la possiede. Tra le due chiavi è presente una relazione matematica che solitamente implica una funzione one-way sottostante, in quanto deve essere molto facile generare una chiave pubblica a partire da una chiave privata ma il contrario non deve essere computazionalmente fattibile. Oltre che cifrare è possibile anche firmare un input con la propria chiave privata così da garantire la sua autenticità. Chiunque per mezzo della chiave pubblica potrà verificare infatti che la firma proviene dalla chiave privata corrispondente.

\subsection{Crittografia ellittica}
La crittografia ellittica è una particolare famiglia di algoritmi a chiave pubblica che si basano sull'uso di curve ellittiche \(y^{2}=x^{3}+ax+b\) su campi finiti. La funzione one-way che protegge la relazione tra le due chiavi è quella del logaritmo discreto. Al contrario di altri algoritmi a chiave pubblica come RSA (basato sulla fattorizzazione in numeri primi) permettono di avere chiavi di dimensioni molto più contenute e un'efficienza di esecuzione molto elevata.

\subsection{Scambio di chiavi tramite Diffie-Hellman}
Lo scambio di chiavi tramite Diffie-Hellman permette a due soggetti di scambiarsi tramite un canale insicuro le proprie chiavi pubbliche, combinandole con le chiavi private in modo tale da giungere ognuno separatamente a una certa quantità. Tale quantità risulterà identica per entrambi grazie alle proprietà matematiche che collegano le chiavi in gioco. Un possibile attaccante in ascolto sul canale non potrà calcolare la stessa quantità in quanto le rispettive chiavi private non hanno mai transitato nel canale, risultando quindi ignote all'attaccante e impossibili da ottenere a partire da quelle pubbliche. La quantità comune ottenuta è tipicamente utilizzata come base per derivare una chiave simmetrica.

\subsection{Algoritmi impiegati}
\begin{description}
   \item[SHA-3] Algoritmo di hashing crittografico pensato come futuro successore della famiglia di algoritmi SHA-2 \cite{sha3}. Usato in UniBlock come puzzle crittografico alla base della proof of work.
   \item[AES] Algoritmo di cifratura simmetrica a blocchi diventato lo standard de facto per questo genere di algoritmi avendo supporto a livello di assembly nella maggior parte delle CPU moderne \cite{aes}. La dimensione dei blocchi è pari a 128 bit. Usato in UniBlock in modalità GCM per criptare il contenuto degli eventi.
   \item[X25519] Algoritmo di scambio di una chiave tramite Diffie-Hellman basato sulla curva ellittica Curve25519 \cite{x25519}. Utilizzato in UniBlock per negoziare tra due utenti una chiave comune.
   \item[Ed25519] Algoritmo di firma a chiave pubblica basato sulla curva ellittica Curve25519 \cite{ed25519}. Usato in UniBlock per firmare gli eventi generati da un utente.
\end{description}
